/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";

/**
 * The object type, which is always `batch`.
 */
export const BatchObject = {
  Batch: "batch",
} as const;
/**
 * The object type, which is always `batch`.
 */
export type BatchObject = ClosedEnum<typeof BatchObject>;

export type BatchData = {
  /**
   * An error code identifying the error type.
   */
  code?: string | undefined;
  /**
   * A human-readable message providing more details about the error.
   */
  message?: string | undefined;
  /**
   * The name of the parameter that caused the error, if applicable.
   */
  param?: string | null | undefined;
  /**
   * The line number of the input file where the error occurred, if applicable.
   */
  line?: number | null | undefined;
};

export type Errors = {
  /**
   * The object type, which is always `list`.
   */
  object?: string | undefined;
  data?: Array<BatchData> | undefined;
};

/**
 * The current status of the batch.
 */
export const BatchStatus = {
  Validating: "validating",
  Failed: "failed",
  InProgress: "in_progress",
  Finalizing: "finalizing",
  Completed: "completed",
  Expired: "expired",
  Cancelling: "cancelling",
  Cancelled: "cancelled",
} as const;
/**
 * The current status of the batch.
 */
export type BatchStatus = ClosedEnum<typeof BatchStatus>;

/**
 * The request counts for different statuses within the batch.
 */
export type RequestCounts = {
  /**
   * Total number of requests in the batch.
   */
  total: number;
  /**
   * Number of requests that have been completed successfully.
   */
  completed: number;
  /**
   * Number of requests that have failed.
   */
  failed: number;
};

/**
 * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
 *
 * @remarks
 */
export type BatchMetadata = {};

export type Batch = {
  id: string;
  /**
   * The object type, which is always `batch`.
   */
  object: BatchObject;
  /**
   * The OpenAI API endpoint used by the batch.
   */
  endpoint: string;
  errors?: Errors | undefined;
  /**
   * The ID of the input file for the batch.
   */
  inputFileId: string;
  /**
   * The time frame within which the batch should be processed.
   */
  completionWindow: string;
  /**
   * The current status of the batch.
   */
  status: BatchStatus;
  /**
   * The ID of the file containing the outputs of successfully executed requests.
   */
  outputFileId?: string | undefined;
  /**
   * The ID of the file containing the outputs of requests with errors.
   */
  errorFileId?: string | undefined;
  /**
   * The Unix timestamp (in seconds) for when the batch was created.
   */
  createdAt: number;
  /**
   * The Unix timestamp (in seconds) for when the batch started processing.
   */
  inProgressAt?: number | undefined;
  /**
   * The Unix timestamp (in seconds) for when the batch will expire.
   */
  expiresAt?: number | undefined;
  /**
   * The Unix timestamp (in seconds) for when the batch started finalizing.
   */
  finalizingAt?: number | undefined;
  /**
   * The Unix timestamp (in seconds) for when the batch was completed.
   */
  completedAt?: number | undefined;
  /**
   * The Unix timestamp (in seconds) for when the batch failed.
   */
  failedAt?: number | undefined;
  /**
   * The Unix timestamp (in seconds) for when the batch expired.
   */
  expiredAt?: number | undefined;
  /**
   * The Unix timestamp (in seconds) for when the batch started cancelling.
   */
  cancellingAt?: number | undefined;
  /**
   * The Unix timestamp (in seconds) for when the batch was cancelled.
   */
  cancelledAt?: number | undefined;
  /**
   * The request counts for different statuses within the batch.
   */
  requestCounts?: RequestCounts | undefined;
  /**
   * Set of 16 key-value pairs that can be attached to an object. This can be useful for storing additional information about the object in a structured format. Keys can be a maximum of 64 characters long and values can be a maximum of 512 characters long.
   *
   * @remarks
   */
  metadata?: BatchMetadata | null | undefined;
};

/** @internal */
export const BatchObject$inboundSchema: z.ZodNativeEnum<typeof BatchObject> = z
  .nativeEnum(BatchObject);

/** @internal */
export const BatchObject$outboundSchema: z.ZodNativeEnum<typeof BatchObject> =
  BatchObject$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BatchObject$ {
  /** @deprecated use `BatchObject$inboundSchema` instead. */
  export const inboundSchema = BatchObject$inboundSchema;
  /** @deprecated use `BatchObject$outboundSchema` instead. */
  export const outboundSchema = BatchObject$outboundSchema;
}

/** @internal */
export const BatchData$inboundSchema: z.ZodType<
  BatchData,
  z.ZodTypeDef,
  unknown
> = z.object({
  code: z.string().optional(),
  message: z.string().optional(),
  param: z.nullable(z.string()).optional(),
  line: z.nullable(z.number().int()).optional(),
});

/** @internal */
export type BatchData$Outbound = {
  code?: string | undefined;
  message?: string | undefined;
  param?: string | null | undefined;
  line?: number | null | undefined;
};

/** @internal */
export const BatchData$outboundSchema: z.ZodType<
  BatchData$Outbound,
  z.ZodTypeDef,
  BatchData
> = z.object({
  code: z.string().optional(),
  message: z.string().optional(),
  param: z.nullable(z.string()).optional(),
  line: z.nullable(z.number().int()).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BatchData$ {
  /** @deprecated use `BatchData$inboundSchema` instead. */
  export const inboundSchema = BatchData$inboundSchema;
  /** @deprecated use `BatchData$outboundSchema` instead. */
  export const outboundSchema = BatchData$outboundSchema;
  /** @deprecated use `BatchData$Outbound` instead. */
  export type Outbound = BatchData$Outbound;
}

export function batchDataToJSON(batchData: BatchData): string {
  return JSON.stringify(BatchData$outboundSchema.parse(batchData));
}

export function batchDataFromJSON(
  jsonString: string,
): SafeParseResult<BatchData, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BatchData$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BatchData' from JSON`,
  );
}

/** @internal */
export const Errors$inboundSchema: z.ZodType<Errors, z.ZodTypeDef, unknown> = z
  .object({
    object: z.string().optional(),
    data: z.array(z.lazy(() => BatchData$inboundSchema)).optional(),
  });

/** @internal */
export type Errors$Outbound = {
  object?: string | undefined;
  data?: Array<BatchData$Outbound> | undefined;
};

/** @internal */
export const Errors$outboundSchema: z.ZodType<
  Errors$Outbound,
  z.ZodTypeDef,
  Errors
> = z.object({
  object: z.string().optional(),
  data: z.array(z.lazy(() => BatchData$outboundSchema)).optional(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Errors$ {
  /** @deprecated use `Errors$inboundSchema` instead. */
  export const inboundSchema = Errors$inboundSchema;
  /** @deprecated use `Errors$outboundSchema` instead. */
  export const outboundSchema = Errors$outboundSchema;
  /** @deprecated use `Errors$Outbound` instead. */
  export type Outbound = Errors$Outbound;
}

export function errorsToJSON(errors: Errors): string {
  return JSON.stringify(Errors$outboundSchema.parse(errors));
}

export function errorsFromJSON(
  jsonString: string,
): SafeParseResult<Errors, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Errors$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Errors' from JSON`,
  );
}

/** @internal */
export const BatchStatus$inboundSchema: z.ZodNativeEnum<typeof BatchStatus> = z
  .nativeEnum(BatchStatus);

/** @internal */
export const BatchStatus$outboundSchema: z.ZodNativeEnum<typeof BatchStatus> =
  BatchStatus$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BatchStatus$ {
  /** @deprecated use `BatchStatus$inboundSchema` instead. */
  export const inboundSchema = BatchStatus$inboundSchema;
  /** @deprecated use `BatchStatus$outboundSchema` instead. */
  export const outboundSchema = BatchStatus$outboundSchema;
}

/** @internal */
export const RequestCounts$inboundSchema: z.ZodType<
  RequestCounts,
  z.ZodTypeDef,
  unknown
> = z.object({
  total: z.number().int(),
  completed: z.number().int(),
  failed: z.number().int(),
});

/** @internal */
export type RequestCounts$Outbound = {
  total: number;
  completed: number;
  failed: number;
};

/** @internal */
export const RequestCounts$outboundSchema: z.ZodType<
  RequestCounts$Outbound,
  z.ZodTypeDef,
  RequestCounts
> = z.object({
  total: z.number().int(),
  completed: z.number().int(),
  failed: z.number().int(),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace RequestCounts$ {
  /** @deprecated use `RequestCounts$inboundSchema` instead. */
  export const inboundSchema = RequestCounts$inboundSchema;
  /** @deprecated use `RequestCounts$outboundSchema` instead. */
  export const outboundSchema = RequestCounts$outboundSchema;
  /** @deprecated use `RequestCounts$Outbound` instead. */
  export type Outbound = RequestCounts$Outbound;
}

export function requestCountsToJSON(requestCounts: RequestCounts): string {
  return JSON.stringify(RequestCounts$outboundSchema.parse(requestCounts));
}

export function requestCountsFromJSON(
  jsonString: string,
): SafeParseResult<RequestCounts, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => RequestCounts$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'RequestCounts' from JSON`,
  );
}

/** @internal */
export const BatchMetadata$inboundSchema: z.ZodType<
  BatchMetadata,
  z.ZodTypeDef,
  unknown
> = z.object({});

/** @internal */
export type BatchMetadata$Outbound = {};

/** @internal */
export const BatchMetadata$outboundSchema: z.ZodType<
  BatchMetadata$Outbound,
  z.ZodTypeDef,
  BatchMetadata
> = z.object({});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace BatchMetadata$ {
  /** @deprecated use `BatchMetadata$inboundSchema` instead. */
  export const inboundSchema = BatchMetadata$inboundSchema;
  /** @deprecated use `BatchMetadata$outboundSchema` instead. */
  export const outboundSchema = BatchMetadata$outboundSchema;
  /** @deprecated use `BatchMetadata$Outbound` instead. */
  export type Outbound = BatchMetadata$Outbound;
}

export function batchMetadataToJSON(batchMetadata: BatchMetadata): string {
  return JSON.stringify(BatchMetadata$outboundSchema.parse(batchMetadata));
}

export function batchMetadataFromJSON(
  jsonString: string,
): SafeParseResult<BatchMetadata, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => BatchMetadata$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'BatchMetadata' from JSON`,
  );
}

/** @internal */
export const Batch$inboundSchema: z.ZodType<Batch, z.ZodTypeDef, unknown> = z
  .object({
    id: z.string(),
    object: BatchObject$inboundSchema,
    endpoint: z.string(),
    errors: z.lazy(() => Errors$inboundSchema).optional(),
    input_file_id: z.string(),
    completion_window: z.string(),
    status: BatchStatus$inboundSchema,
    output_file_id: z.string().optional(),
    error_file_id: z.string().optional(),
    created_at: z.number().int(),
    in_progress_at: z.number().int().optional(),
    expires_at: z.number().int().optional(),
    finalizing_at: z.number().int().optional(),
    completed_at: z.number().int().optional(),
    failed_at: z.number().int().optional(),
    expired_at: z.number().int().optional(),
    cancelling_at: z.number().int().optional(),
    cancelled_at: z.number().int().optional(),
    request_counts: z.lazy(() => RequestCounts$inboundSchema).optional(),
    metadata: z.nullable(z.lazy(() => BatchMetadata$inboundSchema)).optional(),
  }).transform((v) => {
    return remap$(v, {
      "input_file_id": "inputFileId",
      "completion_window": "completionWindow",
      "output_file_id": "outputFileId",
      "error_file_id": "errorFileId",
      "created_at": "createdAt",
      "in_progress_at": "inProgressAt",
      "expires_at": "expiresAt",
      "finalizing_at": "finalizingAt",
      "completed_at": "completedAt",
      "failed_at": "failedAt",
      "expired_at": "expiredAt",
      "cancelling_at": "cancellingAt",
      "cancelled_at": "cancelledAt",
      "request_counts": "requestCounts",
    });
  });

/** @internal */
export type Batch$Outbound = {
  id: string;
  object: string;
  endpoint: string;
  errors?: Errors$Outbound | undefined;
  input_file_id: string;
  completion_window: string;
  status: string;
  output_file_id?: string | undefined;
  error_file_id?: string | undefined;
  created_at: number;
  in_progress_at?: number | undefined;
  expires_at?: number | undefined;
  finalizing_at?: number | undefined;
  completed_at?: number | undefined;
  failed_at?: number | undefined;
  expired_at?: number | undefined;
  cancelling_at?: number | undefined;
  cancelled_at?: number | undefined;
  request_counts?: RequestCounts$Outbound | undefined;
  metadata?: BatchMetadata$Outbound | null | undefined;
};

/** @internal */
export const Batch$outboundSchema: z.ZodType<
  Batch$Outbound,
  z.ZodTypeDef,
  Batch
> = z.object({
  id: z.string(),
  object: BatchObject$outboundSchema,
  endpoint: z.string(),
  errors: z.lazy(() => Errors$outboundSchema).optional(),
  inputFileId: z.string(),
  completionWindow: z.string(),
  status: BatchStatus$outboundSchema,
  outputFileId: z.string().optional(),
  errorFileId: z.string().optional(),
  createdAt: z.number().int(),
  inProgressAt: z.number().int().optional(),
  expiresAt: z.number().int().optional(),
  finalizingAt: z.number().int().optional(),
  completedAt: z.number().int().optional(),
  failedAt: z.number().int().optional(),
  expiredAt: z.number().int().optional(),
  cancellingAt: z.number().int().optional(),
  cancelledAt: z.number().int().optional(),
  requestCounts: z.lazy(() => RequestCounts$outboundSchema).optional(),
  metadata: z.nullable(z.lazy(() => BatchMetadata$outboundSchema)).optional(),
}).transform((v) => {
  return remap$(v, {
    inputFileId: "input_file_id",
    completionWindow: "completion_window",
    outputFileId: "output_file_id",
    errorFileId: "error_file_id",
    createdAt: "created_at",
    inProgressAt: "in_progress_at",
    expiresAt: "expires_at",
    finalizingAt: "finalizing_at",
    completedAt: "completed_at",
    failedAt: "failed_at",
    expiredAt: "expired_at",
    cancellingAt: "cancelling_at",
    cancelledAt: "cancelled_at",
    requestCounts: "request_counts",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace Batch$ {
  /** @deprecated use `Batch$inboundSchema` instead. */
  export const inboundSchema = Batch$inboundSchema;
  /** @deprecated use `Batch$outboundSchema` instead. */
  export const outboundSchema = Batch$outboundSchema;
  /** @deprecated use `Batch$Outbound` instead. */
  export type Outbound = Batch$Outbound;
}

export function batchToJSON(batch: Batch): string {
  return JSON.stringify(Batch$outboundSchema.parse(batch));
}

export function batchFromJSON(
  jsonString: string,
): SafeParseResult<Batch, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => Batch$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'Batch' from JSON`,
  );
}
