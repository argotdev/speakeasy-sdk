/*
 * Code generated by Speakeasy (https://speakeasy.com). DO NOT EDIT.
 */

import * as z from "zod";
import { remap as remap$ } from "../../lib/primitives.js";
import { safeParse } from "../../lib/schemas.js";
import { blobLikeSchema } from "../../types/blobs.js";
import { ClosedEnum } from "../../types/enums.js";
import { Result as SafeParseResult } from "../../types/fp.js";
import { SDKValidationError } from "../errors/sdkvalidationerror.js";
import {
  AudioResponseFormat,
  AudioResponseFormat$inboundSchema,
  AudioResponseFormat$outboundSchema,
} from "./audioresponseformat.js";

export type FileT = {
  fileName: string;
  content: ReadableStream<Uint8Array> | Blob | ArrayBuffer | Uint8Array;
};

export const CreateTranscriptionRequestModel2 = {
  Whisper1: "whisper-1",
} as const;
export type CreateTranscriptionRequestModel2 = ClosedEnum<
  typeof CreateTranscriptionRequestModel2
>;

/**
 * ID of the model to use. Only `whisper-1` (which is powered by our open source Whisper V2 model) is currently available.
 *
 * @remarks
 */
export type CreateTranscriptionRequestModel =
  | string
  | CreateTranscriptionRequestModel2;

export const TimestampGranularities = {
  Word: "word",
  Segment: "segment",
} as const;
export type TimestampGranularities = ClosedEnum<typeof TimestampGranularities>;

export type CreateTranscriptionRequest = {
  /**
   * The audio file object (not file name) to transcribe, in one of these formats: flac, mp3, mp4, mpeg, mpga, m4a, ogg, wav, or webm.
   *
   * @remarks
   */
  file: FileT | Blob;
  /**
   * ID of the model to use. Only `whisper-1` (which is powered by our open source Whisper V2 model) is currently available.
   *
   * @remarks
   */
  model: string | CreateTranscriptionRequestModel2;
  /**
   * The language of the input audio. Supplying the input language in [ISO-639-1](https://en.wikipedia.org/wiki/List_of_ISO_639-1_codes) format will improve accuracy and latency.
   *
   * @remarks
   */
  language?: string | undefined;
  /**
   * An optional text to guide the model's style or continue a previous audio segment. The [prompt](/docs/guides/speech-to-text/prompting) should match the audio language.
   *
   * @remarks
   */
  prompt?: string | undefined;
  /**
   * The format of the output, in one of these options: `json`, `text`, `srt`, `verbose_json`, or `vtt`.
   *
   * @remarks
   */
  responseFormat?: AudioResponseFormat | undefined;
  /**
   * The sampling temperature, between 0 and 1. Higher values like 0.8 will make the output more random, while lower values like 0.2 will make it more focused and deterministic. If set to 0, the model will use [log probability](https://en.wikipedia.org/wiki/Log_probability) to automatically increase the temperature until certain thresholds are hit.
   *
   * @remarks
   */
  temperature?: number | undefined;
  /**
   * The timestamp granularities to populate for this transcription. `response_format` must be set `verbose_json` to use timestamp granularities. Either or both of these options are supported: `word`, or `segment`. Note: There is no additional latency for segment timestamps, but generating word timestamps incurs additional latency.
   *
   * @remarks
   */
  timestampGranularities?: Array<TimestampGranularities> | undefined;
};

/** @internal */
export const FileT$inboundSchema: z.ZodType<FileT, z.ZodTypeDef, unknown> = z
  .object({
    fileName: z.string(),
    content: z.union([
      z.instanceof(ReadableStream<Uint8Array>),
      z.instanceof(Blob),
      z.instanceof(ArrayBuffer),
      z.instanceof(Uint8Array),
    ]),
  });

/** @internal */
export type FileT$Outbound = {
  fileName: string;
  content: ReadableStream<Uint8Array> | Blob | ArrayBuffer | Uint8Array;
};

/** @internal */
export const FileT$outboundSchema: z.ZodType<
  FileT$Outbound,
  z.ZodTypeDef,
  FileT
> = z.object({
  fileName: z.string(),
  content: z.union([
    z.instanceof(ReadableStream<Uint8Array>),
    z.instanceof(Blob),
    z.instanceof(ArrayBuffer),
    z.instanceof(Uint8Array),
  ]),
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace FileT$ {
  /** @deprecated use `FileT$inboundSchema` instead. */
  export const inboundSchema = FileT$inboundSchema;
  /** @deprecated use `FileT$outboundSchema` instead. */
  export const outboundSchema = FileT$outboundSchema;
  /** @deprecated use `FileT$Outbound` instead. */
  export type Outbound = FileT$Outbound;
}

export function fileToJSON(fileT: FileT): string {
  return JSON.stringify(FileT$outboundSchema.parse(fileT));
}

export function fileFromJSON(
  jsonString: string,
): SafeParseResult<FileT, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => FileT$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'FileT' from JSON`,
  );
}

/** @internal */
export const CreateTranscriptionRequestModel2$inboundSchema: z.ZodNativeEnum<
  typeof CreateTranscriptionRequestModel2
> = z.nativeEnum(CreateTranscriptionRequestModel2);

/** @internal */
export const CreateTranscriptionRequestModel2$outboundSchema: z.ZodNativeEnum<
  typeof CreateTranscriptionRequestModel2
> = CreateTranscriptionRequestModel2$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateTranscriptionRequestModel2$ {
  /** @deprecated use `CreateTranscriptionRequestModel2$inboundSchema` instead. */
  export const inboundSchema = CreateTranscriptionRequestModel2$inboundSchema;
  /** @deprecated use `CreateTranscriptionRequestModel2$outboundSchema` instead. */
  export const outboundSchema = CreateTranscriptionRequestModel2$outboundSchema;
}

/** @internal */
export const CreateTranscriptionRequestModel$inboundSchema: z.ZodType<
  CreateTranscriptionRequestModel,
  z.ZodTypeDef,
  unknown
> = z.union([z.string(), CreateTranscriptionRequestModel2$inboundSchema]);

/** @internal */
export type CreateTranscriptionRequestModel$Outbound = string | string;

/** @internal */
export const CreateTranscriptionRequestModel$outboundSchema: z.ZodType<
  CreateTranscriptionRequestModel$Outbound,
  z.ZodTypeDef,
  CreateTranscriptionRequestModel
> = z.union([z.string(), CreateTranscriptionRequestModel2$outboundSchema]);

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateTranscriptionRequestModel$ {
  /** @deprecated use `CreateTranscriptionRequestModel$inboundSchema` instead. */
  export const inboundSchema = CreateTranscriptionRequestModel$inboundSchema;
  /** @deprecated use `CreateTranscriptionRequestModel$outboundSchema` instead. */
  export const outboundSchema = CreateTranscriptionRequestModel$outboundSchema;
  /** @deprecated use `CreateTranscriptionRequestModel$Outbound` instead. */
  export type Outbound = CreateTranscriptionRequestModel$Outbound;
}

export function createTranscriptionRequestModelToJSON(
  createTranscriptionRequestModel: CreateTranscriptionRequestModel,
): string {
  return JSON.stringify(
    CreateTranscriptionRequestModel$outboundSchema.parse(
      createTranscriptionRequestModel,
    ),
  );
}

export function createTranscriptionRequestModelFromJSON(
  jsonString: string,
): SafeParseResult<CreateTranscriptionRequestModel, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateTranscriptionRequestModel$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateTranscriptionRequestModel' from JSON`,
  );
}

/** @internal */
export const TimestampGranularities$inboundSchema: z.ZodNativeEnum<
  typeof TimestampGranularities
> = z.nativeEnum(TimestampGranularities);

/** @internal */
export const TimestampGranularities$outboundSchema: z.ZodNativeEnum<
  typeof TimestampGranularities
> = TimestampGranularities$inboundSchema;

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace TimestampGranularities$ {
  /** @deprecated use `TimestampGranularities$inboundSchema` instead. */
  export const inboundSchema = TimestampGranularities$inboundSchema;
  /** @deprecated use `TimestampGranularities$outboundSchema` instead. */
  export const outboundSchema = TimestampGranularities$outboundSchema;
}

/** @internal */
export const CreateTranscriptionRequest$inboundSchema: z.ZodType<
  CreateTranscriptionRequest,
  z.ZodTypeDef,
  unknown
> = z.object({
  file: z.lazy(() => FileT$inboundSchema),
  model: z.union([z.string(), CreateTranscriptionRequestModel2$inboundSchema]),
  language: z.string().optional(),
  prompt: z.string().optional(),
  response_format: AudioResponseFormat$inboundSchema.default("json"),
  temperature: z.number().default(0),
  "timestamp_granularities[]": z.array(TimestampGranularities$inboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    "response_format": "responseFormat",
    "timestamp_granularities[]": "timestampGranularities",
  });
});

/** @internal */
export type CreateTranscriptionRequest$Outbound = {
  file: FileT$Outbound | Blob;
  model: string | string;
  language?: string | undefined;
  prompt?: string | undefined;
  response_format: string;
  temperature: number;
  "timestamp_granularities[]"?: Array<string> | undefined;
};

/** @internal */
export const CreateTranscriptionRequest$outboundSchema: z.ZodType<
  CreateTranscriptionRequest$Outbound,
  z.ZodTypeDef,
  CreateTranscriptionRequest
> = z.object({
  file: z.lazy(() => FileT$outboundSchema).or(blobLikeSchema),
  model: z.union([z.string(), CreateTranscriptionRequestModel2$outboundSchema]),
  language: z.string().optional(),
  prompt: z.string().optional(),
  responseFormat: AudioResponseFormat$outboundSchema.default("json"),
  temperature: z.number().default(0),
  timestampGranularities: z.array(TimestampGranularities$outboundSchema)
    .optional(),
}).transform((v) => {
  return remap$(v, {
    responseFormat: "response_format",
    timestampGranularities: "timestamp_granularities[]",
  });
});

/**
 * @internal
 * @deprecated This namespace will be removed in future versions. Use schemas and types that are exported directly from this module.
 */
export namespace CreateTranscriptionRequest$ {
  /** @deprecated use `CreateTranscriptionRequest$inboundSchema` instead. */
  export const inboundSchema = CreateTranscriptionRequest$inboundSchema;
  /** @deprecated use `CreateTranscriptionRequest$outboundSchema` instead. */
  export const outboundSchema = CreateTranscriptionRequest$outboundSchema;
  /** @deprecated use `CreateTranscriptionRequest$Outbound` instead. */
  export type Outbound = CreateTranscriptionRequest$Outbound;
}

export function createTranscriptionRequestToJSON(
  createTranscriptionRequest: CreateTranscriptionRequest,
): string {
  return JSON.stringify(
    CreateTranscriptionRequest$outboundSchema.parse(createTranscriptionRequest),
  );
}

export function createTranscriptionRequestFromJSON(
  jsonString: string,
): SafeParseResult<CreateTranscriptionRequest, SDKValidationError> {
  return safeParse(
    jsonString,
    (x) => CreateTranscriptionRequest$inboundSchema.parse(JSON.parse(x)),
    `Failed to parse 'CreateTranscriptionRequest' from JSON`,
  );
}
